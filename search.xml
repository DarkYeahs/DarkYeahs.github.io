<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTTP状态码]]></title>
    <url>%2F2019%2F04%2F28%2FHTTP%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HTTP状态码（英文：HTTP status code）是用以表示网页服务器超文本传输协议响应状态的3位数字码 1xx消息&nbsp;&nbsp;&nbsp;&nbsp;这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。 100 Continue&nbsp;&nbsp;&nbsp;&nbsp;服务器已经接收到请求头，并且客户端应继续发送请求主体（在需要发送身体的请求的情况下：例如，POST请求），或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。要使服务器检查请求的头部，客户端必须在其初始请求中发送Expect: 100-continue作为头部，并在发送正文之前接收100 Continue状态代码。响应代码417期望失败表示请求不应继续。 101 Switching Protocols&nbsp;&nbsp;&nbsp;&nbsp;服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议（如WebSocket）以传送利用此类特性的资源。 102 Processing&nbsp;&nbsp;&nbsp;&nbsp;WebDAV请求可能包含许多涉及文件操作的子请求，需要很长时间才能完成请求。该代码表示​​服务器已经收到并正在处理请求，但无响应可用。这样可以防止客户端超时，并假设请求丢失。 2xx成功&nbsp;&nbsp;&nbsp;&nbsp;这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 200 OK&nbsp;&nbsp;&nbsp;&nbsp;请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。 201 Created&nbsp;&nbsp;&nbsp;&nbsp;请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。 202 Accepted&nbsp;&nbsp;&nbsp;&nbsp;服务器已接受请求，但尚未处理。最终该请求可能会也可能不会被执行，并且可能在处理发生时被禁止。 203 Non-Authoritative Information（自HTTP / 1.1起）&nbsp;&nbsp;&nbsp;&nbsp;服务器是一个转换代理服务器（transforming proxy，例如网络加速器），以200 OK状态码为起源，但回应了原始响应的修改版本。 204 No Content&nbsp;&nbsp;&nbsp;&nbsp;服务器成功处理了请求，没有返回任何内容。（put或者delete请求） 205 Reset Content&nbsp;&nbsp;&nbsp;&nbsp;服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。 206 Partial Content&nbsp;&nbsp;&nbsp;&nbsp;服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 207 Multi-Status&nbsp;&nbsp;&nbsp;&nbsp;代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 208 Already Reported&nbsp;&nbsp;&nbsp;&nbsp;DAV绑定的成员已经在（多状态）响应之前的部分被列举，且未被再次包含。 226 IM Used&nbsp;&nbsp;&nbsp;&nbsp;服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。[16] 3xx重定向&nbsp;&nbsp;&nbsp;&nbsp;这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。 &nbsp;&nbsp;&nbsp;&nbsp;当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 300 Multiple Choices&nbsp;&nbsp;&nbsp;&nbsp;被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 &nbsp;&nbsp;&nbsp;&nbsp;除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 &nbsp;&nbsp;&nbsp;&nbsp;如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 Moved Permanently&nbsp;&nbsp;&nbsp;&nbsp;被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 &nbsp;&nbsp;&nbsp;&nbsp;新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 &nbsp;&nbsp;&nbsp;&nbsp;如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 &nbsp;&nbsp;&nbsp;&nbsp;注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。 302 Found&nbsp;&nbsp;&nbsp;&nbsp;要求客户端执行临时重定向（原始描述短语为“Moved Temporarily”）。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 &nbsp;&nbsp;&nbsp;&nbsp;新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 &nbsp;&nbsp;&nbsp;&nbsp;如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 &nbsp;&nbsp;&nbsp;&nbsp;注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。因此状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 See Other&nbsp;&nbsp;&nbsp;&nbsp;对应当前请求的响应可以在另一个URI上被找到，当响应于POST（或PUT / DELETE）接收到响应时，客户端应该假定服务器已经收到数据，并且应该使用单独的GET消息发出重定向。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 &nbsp;&nbsp;&nbsp;&nbsp;新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。 &nbsp;&nbsp;&nbsp;&nbsp;注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 Not Modified&nbsp;&nbsp;&nbsp;&nbsp;表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后，未曾被修改。在这种情况下，由于客户端仍然具有以前下载的副本，因此不需要重新传输资源。 305 Use Proxy&nbsp;&nbsp;&nbsp;&nbsp;被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。许多HTTP客户端（像是Mozilla[25]和Internet Explorer）都没有正确处理这种状态代码的响应，主要是出于安全考虑。&nbsp;&nbsp;&nbsp;&nbsp;注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 Switch Proxy&nbsp;&nbsp;&nbsp;&nbsp;在最新版的规范中，306状态码已经不再被使用。最初是指“后续请求应使用指定的代理”。 307 Temporary Redirect&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，请求应该与另一个URI重复，但后续的请求应仍使用原始的URI。 与302相反，当重新发出原始请求时，不允许更改请求方法。 例如，应该使用另一个POST请求来重复POST请求。 308 Permanent Redirect (RFC 7538)&nbsp;&nbsp;&nbsp;&nbsp;请求和所有将来的请求应该使用另一个URI重复。 307和308重复302和301的行为，但不允许HTTP方法更改。 例如，将表单提交给永久重定向的资源可能会顺利进行。 4xx客户端错误&nbsp;&nbsp;&nbsp;&nbsp;这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。 &nbsp;&nbsp;&nbsp;&nbsp;如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 400 Bad Request&nbsp;&nbsp;&nbsp;&nbsp;由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。 401 Unauthorized&nbsp;&nbsp;&nbsp;&nbsp;类似于403 Forbidden，401语义即“未认证”，即用户没有必要的凭据。该状态码表示当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。&nbsp;&nbsp;&nbsp;&nbsp;注意：当网站（通常是网站域名）禁止IP地址时，有些网站状态码显示的401，表示该特定地址被拒绝访问网站。 402 Payment Required&nbsp;&nbsp;&nbsp;&nbsp;该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。 403 Forbidden&nbsp;&nbsp;&nbsp;&nbsp;服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found&nbsp;&nbsp;&nbsp;&nbsp;请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 Method Not Allowed&nbsp;&nbsp;&nbsp;&nbsp;请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。例如，需要通过POST呈现数据的表单上的GET请求，或只读资源上的PUT请求。&nbsp;&nbsp;&nbsp;&nbsp;鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 Not Acceptable&nbsp;&nbsp;&nbsp;&nbsp;请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体，该请求不可接受。 &nbsp;&nbsp;&nbsp;&nbsp;除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址栏表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 Proxy Authentication Required&nbsp;&nbsp;&nbsp;&nbsp;与401响应类似，只不过客户端必须在代理服务器上进行身份验证。[37]代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。 408 Request Timeout&nbsp;&nbsp;&nbsp;&nbsp;请求超时。根据HTTP规范，客户端没有在服务器预备等待的时间内完成一个请求的发送，客户端可以随时再次提交这一请求而无需进行任何更改。 409 Conflict&nbsp;&nbsp;&nbsp;&nbsp;表示因为请求存在冲突无法处理该请求，例如多个同步更新之间的编辑冲突。 410 Gone&nbsp;&nbsp;&nbsp;&nbsp;表示所请求的资源不再可用，将不再可用。当资源被有意地删除并且资源应被清除时，应该使用这个。在收到410状态码后，用户应停止再次请求资源。但大多数服务端不会使用此状态码，而是直接使用404状态码。 411 Length Required&nbsp;&nbsp;&nbsp;&nbsp;服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。 412 Precondition Failed&nbsp;&nbsp;&nbsp;&nbsp;服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 Request Entity Too Large&nbsp;&nbsp;&nbsp;&nbsp;前称“Request Entity Too Large”，表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 &nbsp;&nbsp;&nbsp;&nbsp;如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long&nbsp;&nbsp;&nbsp;&nbsp;前称“Request-URI Too Long”，表示请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。通常将太多数据的结果编码为GET请求的查询字符串，在这种情况下，应将其转换为POST请求。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串过长。 重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行。没有此类漏洞的服务器，应当返回414状态码。415 Unsupported Media Type&nbsp;&nbsp;&nbsp;&nbsp;对于当前请求的方法和所请求的资源，请求中提交的互联网媒体类型并不是服务器中所支持的格式，因此请求被拒绝。例如，客户端将图像上传格式为svg，但服务器要求图像使用上传格式为jpg。416 Requested Range Not Satisfiable&nbsp;&nbsp;&nbsp;&nbsp;前称“Requested Range Not Satisfiable”。客户端已经要求文件的一部分（Byte serving），但服务器不能提供该部分。例如，如果客户端要求文件的一部分超出文件尾端。417 Expectation Failed&nbsp;&nbsp;&nbsp;&nbsp;在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。418 I’m a teapot&nbsp;&nbsp;&nbsp;&nbsp;本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议’中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。420 Enhance Your Caim&nbsp;&nbsp;&nbsp;&nbsp;Twitter Search与Trends API在客户端被限速的情况下返回。421 Misdirected Request&nbsp;&nbsp;&nbsp;&nbsp;该请求针对的是无法产生响应的服务器（例如因为连接重用）。422 Unprocessable Entity&nbsp;&nbsp;&nbsp;&nbsp;请求格式正确，但是由于含有语义错误，无法响应。423 Locked&nbsp;&nbsp;&nbsp;&nbsp;当前资源被锁定。424 Failed Dependency&nbsp;&nbsp;&nbsp;&nbsp;由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。425 Unordered Collection&nbsp;&nbsp;&nbsp;&nbsp;在WebDAV Advanced Collections Protocol中定义，但Web Distributed Authoring and Versioning (WebDAV) Ordered Collections Protocol中并不存在。426 Upgrade Required&nbsp;&nbsp;&nbsp;&nbsp;客户端应当切换到TLS/1.0，并在HTTP/1.1 Upgrade header中给出。&nbsp;&nbsp;&nbsp;&nbsp;428 Precondition Required (RFC 6585)&nbsp;&nbsp;&nbsp;&nbsp;原服务器要求该请求满足一定条件。这是为了防止“‘未更新’问题，即客户端读取（GET）一个资源的状态，更改它，并将它写（PUT）回服务器，但这期间第三方已经在服务器上更改了该资源的状态，因此导致了冲突。”429 Too Many Requests （RFC 6585）&nbsp;&nbsp;&nbsp;&nbsp;用户在给定的时间内发送了太多的请求。旨在用于网络限速。431 Request Header Fields Too Large （RFC 6585）&nbsp;&nbsp;&nbsp;&nbsp;服务器不愿处理请求，因为一个或多个头字段过大。444 No Response&nbsp;&nbsp;&nbsp;&nbsp;Nginx上HTTP服务器扩展。服务器不向客户端返回任何信息，并关闭连接（有助于阻止恶意软件）。450 Blocked by Windows Parental Controls&nbsp;&nbsp;&nbsp;&nbsp;这是一个由Windows家庭控制（Microsoft）HTTP阻止的450状态代码的示例，用于信息和测试。451 Unavailable For Legal Reasons&nbsp;&nbsp;&nbsp;&nbsp;该访问因法律的要求而被拒绝，由IETF在2015核准后新增加。494 Request Header Too Large&nbsp;&nbsp;&nbsp;&nbsp;在错误代码431提出之前Nginx上使用的扩展HTTP代码。5xx服务器错误&nbsp;&nbsp;&nbsp;&nbsp;表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。 500 Internal Server Error&nbsp;&nbsp;&nbsp;&nbsp;通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。没有给出具体错误信息。 501 Not Implemented&nbsp;&nbsp;&nbsp;&nbsp;服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能） 502 Bad Gateway&nbsp;&nbsp;&nbsp;&nbsp;作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。[60] 503 Service Unavailable&nbsp;&nbsp;&nbsp;&nbsp;由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是暂时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。 504 Gateway Timeout&nbsp;&nbsp;&nbsp;&nbsp;作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 &nbsp;&nbsp;&nbsp;&nbsp;注意：某些代理服务器在DNS查询超时时会返回400或者500错误。 505 HTTP Version Not Supported&nbsp;&nbsp;&nbsp;&nbsp;服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 Variant Also Negotiates（RFC 2295）&nbsp;&nbsp;&nbsp;&nbsp;由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误，被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 Insufficient Storage（WebDAV；RFC 4918）&nbsp;&nbsp;&nbsp;&nbsp;服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。 508 Loop Detected （WebDAV；RFC 5842）&nbsp;&nbsp;&nbsp;&nbsp;服务器在处理请求时陷入死循环。 （可代替 208状态码） 510 Not Extended（RFC 2774）&nbsp;&nbsp;&nbsp;&nbsp;获取资源所需要的策略并没有被满足。 511 Network Authentication Required （RFC 6585）&nbsp;&nbsp;&nbsp;&nbsp;客户端需要进行身份验证才能获得网络访问权限，旨在限制用户群访问特定网络。（例如连接WiFi热点时的强制网络门户） 非官方状态码420 Enhance Your Calm&nbsp;&nbsp;&nbsp;&nbsp;据说早期 Twitter API 会在短期内提交太多需求的时候回传这个 Status Code，不过在新版 API 改为使用 429 Too Many Requests。 498 Invalid Token499 Token Required&nbsp;&nbsp;&nbsp;&nbsp;这两个是以前一个叫做 ArcGIS for Server 的系统会回应的 Status Code。一般来说验证信息错误还是会回传 401 Unathorized。 520 Unknown Error&nbsp;&nbsp;&nbsp;&nbsp;Cloudflare 会用的未知错误。 521 Web Server Is Down&nbsp;&nbsp;&nbsp;&nbsp;指目标服务器挂了，一般在一些CDN上会出现（例如Cloudflare）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome插件开发小结]]></title>
    <url>%2F2019%2F04%2F26%2Fchrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;最近写了一个很简单的chrome插件todolist，一个很常见的任务列表插件，主要功能有 任务列表展示 任务完成操作 任务新增 桌面通知 &nbsp;&nbsp;项目地址是这个todoList,整理下开发的流程以及开发过程中遇到的问题。 开发历程&nbsp;&nbsp;这里讲的是开发过程的目录结构，chrome会读取根目录下的manifest.json文件配置,这里项目的配置如下1234567891011121314151617181920212223242526272829303132333435&#123; "manifest_version": 2, "name": "todolist", "version": "1.0", "description": "todolist", "icons": &#123; "16": "images/icon16.png", "48": "images/icon48.png", "128": "images/icon128.png" &#125;, "browser_action": &#123; "default_icon": &#123; "19": "images/icon19.png", "38": "images/icon38.png" &#125;, "default_title": "个人计划列表", "default_popup": "./dist/popup.html" &#125;, "permissions": [ "*://*/", "notifications" ], "web_accessible_resources": [ "images/*.png" ], "background": &#123; "page": "./dist/background.html" &#125;, "content_security_policy": "script-src 'self' 'unsafe-eval' http://localhost:4000; object-src 'self';"&#125; &nbsp;&nbsp;第一个字段manifest_version指的是使用的manifest.json的版本，目前1的版本已经被废弃了，所以使用的是2的版本。name、version、description以及icon字段分别对应插件名、插件版本、插件描述以及插件icon,这些配置会在插件安装的时候展示给用户。 &nbsp;&nbsp;browser_action字段则是声明会在浏览器的工具栏添加的操作，在这里声明了在工具栏添加一个icon以及对应的popup页面 &nbsp;&nbsp;permissions，web_accessible_resources则是声明插件需要的权限以及接收资源的格式，这里申请的是chrome桌面通知权限以及网络请求权限（PS:这里通配符匹配了任意请求地址），接收的资源格式是images/*.png格式 &nbsp;&nbsp;background则是声明后台常驻脚本/页面 &nbsp;&nbsp;项目主要由两部分构成，一个是popup页面以及后台运行页面，popup页面在用户打开工作栏上对应的插件按钮时会运行展示，后台运行页面则是在浏览器打开的时候就会在后台运行，直到浏览器关闭才会停止。 &nbsp;&nbsp;popup页面主要的功能有 任务列表展示 任务列表状态更改 任务新增 &nbsp;&nbsp;后台页面主要的功能有 数据请求 任务通知 内容比较简单，具体可以参照代码查看。 开发中遇到的问题 跨域问题 在popup页面上不能进行跨域请求，处理的方式，将请求发起放到background.html上，popup页面通过调用chrome的chrome.runtime.sendMessage向background.html发起请求，由background.html向服务端发起请求并将请求到的结果返回给popup页面。 页面点击会导致以下报错，但不会导致页面本身执行失败 1Refused to execute JavaScript URL because it violates the following Content Security Policy directive: &quot;script-src &apos;self&apos; chrome-extension://&quot;. Either the &apos;unsafe-inline&apos; keyword, a hash (&apos;sha256-...&apos;), or a nonce (&apos;nonce-...&apos;) is required to enable inline execution. 搜了下是chrome插件关于CSP的协议的控制，chrome最新的插件不允许内联js运行，搜索代码发现是因为href=&quot;javascript:;&quot;导致的，将href=&quot;javascript:;&quot;去除即可]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>chrome 插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存整理]]></title>
    <url>%2F2019%2F04%2F25%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E7%BC%93%E5%AD%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理下关于浏览器请求缓存浏览器请求缓存分为强缓存与协商缓存 强缓存浏览器访问资源前会先检查本地是否请求过该资源，如果请求过该资源，会先判断该资源上一次请求的expires字段以及cache-control字段。如果存在expires字段以及cache-control字段，会判断当前是否过期，如果过期，则会向服务器发起请求，如果未过期，则不会向服务器发起请求，直接使用本地缓存。 浏览器如果第一次请求同时返回cache-control以及expires时，下次校验强缓存是否过期时expire会被cache-control覆盖。expires返回的是服务器时间，比对的时候是跟本地时间进行比对。 Cache-ControlCache-Control定义了一组关于缓存的控制字段，常用的有以下几个： no-cache： 指定返回的响应在未经服务器检查其是否被修改之前，不能使用。就是说没有经过服务器确认的缓存是被禁止的，但是经过服务器确认未变更的资源可以避免重复下载。 no-store： 这个是简单粗暴地直接禁止浏览器和所有的中继缓存()储存任何版本的返回响应。 public： 响应可以被缓存(默认)。 private： 响应可以由浏览器缓存(用户)，但是不允许任何中继缓存(CDN)进行缓存。 max-age: 指示获取到的响应，从发送请求开始以秒计算，可以重新使用的最长时间间隔。 强缓存还分from dist cache以及from memory cache，from dist cache字面上指的是从硬盘里读取缓存，from memory cache指的是从缓存中读取，如果浏览器关闭，from memory cache会直接进行清除。 强缓存的状态码是200 协商缓存在当前强缓存过期的情况下，会向服务器发起请求，在发起的请求头上会带上If-None-match(上一次请求返回的ETag)字段或者If-modify-match(上一次请求返回的last-modify)字段，服务器会优先校验请求头的If-not-match字段与服务器上文件的字段是否一致，一致则返回304响应码并在返回的请求头上带上Etag字段，告诉浏览器使用本地缓存。如果没有If-not-match字段，则会校验请求头中的If-modify-match字段，与服务器文件上最后一次修改时间进行比较，如果一致则返回304并在返回的请求头上带上last-match，浏览器使用本地缓存。如果两者校验都不通过，则返回200状态码，浏览器从服务器加载资源。 协商缓存校验过程中，ETag/If-None-match以及last-modify/if-modify-since是配套校验的，并且ETag/If-None-match的优先级比last-modify/if-modify-since优先级高，因为服务器校验的时间精度可能不准确以及文件内容未修改但文件修改时间未发生变化等。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期问题汇总]]></title>
    <url>%2F2018%2F04%2F20%2F%E8%BF%91%E6%9C%9F%E5%85%BC%E5%AE%B9%E8%A1%8C%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[整理下近期工作中遇到的问题 安卓rem兼容问题 在部分安卓机型里存在1rem不等于根元素上字体大小的问题。理论上如果设定根元素大小为16px，那么1rem应该就等于16px，但是在部分安卓机型（常见vivo，oppo机型）中会出现1rem不等于16px的现象。此时可以根据根元素的字体大小设定一个dom元素插入文档，通过调用dom元素上的getBoundingClientRect获取元素在dom文档中实际的大小，通过理论的数值与真实的数值进行判断。如果两个数值不等，则将根元素上的字体大小按照理论数值与真实数值的比例放大或者缩小。 如果使用rem进行布局，那么会经常出现计算出来的元素大小像素存在小数点，而浏览器渲染页面是按照屏幕的渲染单位进行渲染的，这种情况下无法避免，只能在布局中进行留意。 placeholder字体发生变化会导致placeholder字体发生位移通过设定::-webkit-input-placeholder对input下的placeholder属性设定的预留字体进行加粗变化字体类型会导致placeholder设定的字体在小米手机上发生位移 华为 华为不支持多行flex布局。华为机型不支持多行flex布局，因为大多数华为机型只支持古老的flex-box布局，flex-box不支持多行布局，只支持单行的flex布局。所以在选定多行布局的时候，对flex的使用要多加谨慎，且对flex的预编译要选定兼容到最老的那一个选项。 虽然在移动端使用transform以及设定translate3D可以开启硬件加速，但是要考虑在部分机型使用后页面滑动元素滚动怪异的问题，常见于页面发生滑动，使用了transform属性的元素会滞后滑动（不同步滑动）多数安卓浏览器播放视频会使用自身的浏览器，且浏览器无法被遮盖 ios vue以及react后退会导致页面空白 ios下元素需要使用onstarttouch属性才能激活元素的active渲染 iphoneX在safari浏览器横屏下两边会自动留白工具 使用webpack打包时如果webpack的配置中output.jsonpfunction配置重复会导致打包资源发生冲突 offline-plugin 离线资源加载优化，二次加载的时间可以优化到只需要原先加载时间的1/3，但使用会导致qq分享失败，影响到qq的分享接口的api报错（问题暂时未知）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行上下文知识整理]]></title>
    <url>%2F2017%2F11%2F02%2FJavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前几天在GitHub上看到了mqyqingfeng的博客，在上面看了他的JavaScript深入系列中关于执行上下文部分的讲述，对于JavaScript的执行上下文有了进一步的了解,在这里总结下我新的认识。 执行上下文首先说下什么是执行上下文，HTML规范上是这么说的 When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context. 简单的来说就是当可执行代码被执行的时候，会创建一个执行上下文，这个上下文就是当前可执行代码的执行环境。并且多个执行上下文会构成一个执行上下文栈，栈底部始终存在着一个GlobalContext。其中可执行代码分为1. 全局代码;2. 函数代码;3. eval代码。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。其中，在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行上下文的代码会分成两个阶段进行处理：分析和执行。 分析当进入执行上下文时，这时候只是进行代码的解析(变量命名的提升就在这一阶段)，变量对象会包括：a) 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined b) 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 c) 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 执行在执行阶段，浏览器会顺序执行代码，根据代码，修改变量对象的值 举个🌰：12345678function foo (a) &#123; var b = 1 function bar () &#123; &#125; var d = function () &#123;&#125; b = 2&#125;foo(1) 在分析阶段，这个时候的AO是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, bar: reference to function c()&#123;&#125;, d: undefined&#125; 在执行阶段，这个时候的AO是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 2, bar: reference to function c()&#123;&#125;, d: reference to FunctionExpression "d"&#125; 作用域链在上面说到每个上下文都有一个变量对象，而由多个上下文的变量对象构成的链表就叫做作用域链。其中，函数的作用域链在函数定义的时候就决定了。在函数创建的时候，会把所有的父变量对象保存到函数的一个内部属性中。举个🌰：12345function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为：12345678foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 this再这里就先不展开了，单纯从ECMAScript的角度讲有点绕，也有点多。。。懒病又犯了。。。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于一道js题目的猜想]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%85%B3%E4%BA%8E%E4%B8%80%E9%81%93js%E9%A2%98%E7%9B%AE%E7%9A%84%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[昨天在GitHub上无意逛到了creeperyang的博客,在他博客的JavaScript问题集锦，看到了这道题：问题： 尝试解释下连等赋值的过程。下面的代码为什么是这样的输出？12345var a = &#123;n: 1&#125;; var b = a;a.x = a = &#123;n: 2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 博主是这样解释的： 按照es5规范，题中连等赋值等价于a.x = (a = {n: 2});，按优先获取左引用（lref），然后获取右引用（rref）的顺序，a.x和a中的a都指向了{n: 1}。至此，至关重要或者说最迷惑的一步明确。(a = {n: 2})执行完成后，变量a指向{n: 2}，并返回{n: 2};接着执行a.x = {n: 2}，这里的a就是b（指向{n: 1}），所以b.x就指向了{n: 2}。 后面自己想了下有点解释不通，因为当a的指向更改的时候，a.x中的a指向也应该同时更改，那么x属性也应该是在新的对象上添加，为什么会说这里的a仍然就是b即指向的是{n: 1},所以对原代码进行了改造：12345678var a = &#123;n: 1&#125;; var b = a;function test () &#123; return a = &#123;n: 2&#125;;&#125;a.x = test();console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 运行结果与原结果相同。在使用chrome的debugger查看代码运行的时候，发现chrome在运行过程中，运行到a.x = test()这行代码的时候会停留在a.x再运行test(),联系到关于属性在原型链上的搜索，作出以下的解释：a.x = a = {n: 2}在运行过程中浏览器会首先尝试读取属性x的值，即在{n: 1}上搜索x属性，在搜索不到的前提下又由于赋值的操作，会在{n: 1}上创建x属性并且x属性指向{n: 2},由于a的指向发生变更,所以a.x为undefined,b.x为{n: 2}js执行连等赋值语句之前，会取出变量的引用。a.x = a = {n: 2}在运行过程中，由于.运算符的优先级比=运算符优先级高，所以浏览器会先执行a.x的操作，也就是读取a的操作，此时a仍指向{n: 1}，执行结果为undefined，但是由于赋值操作，此时会给{n: 1}增加x属性这个值，所以a.x中的a仍然指向{n: 1}，且属性x的值为a = {n: 2}的执行结果。因为在执行a = {n: 2}的过程中改变了a的指向，所以console.log(a.x)其结果为undefined，b.x结果为{n: 1}。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.x周期简述]]></title>
    <url>%2F2017%2F10%2F28%2FVue2-x%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[首先贴一张大图，跟vue1.x相比。vue2.0渲染周期发生了较大的变化。Vue的生命周期变为beforeCreate（Vue1.x为created），created（vue1.x为beforeCompile），beforeMount（vue1.x为compile），mounted（vue1.x为ready）以及beforeDestroy，destroyed. beforeCreate周期在beforeCreate周期前是获取不到任何数据的，这个周期只是进行事件的初始化以及生命周期的初始化，在完成事件的初始化以及生命周期的初始化后会触发beforeCreate的钩子函数，对于无关数据与渲染后的dom操作的可以在这个周期开始执行 created周期在created周期前，对数据通过vue本身改造Object.prototype.setter 和Object.prototype.getter两个函数对传入的数据进行监听，在这个周期可以对无关dom的操作进行处理，比如根据传入的数据获取后台数据等操作可以在这个周期进行 beforeMount周期在这个周期主要完成虚拟dom操作，Vue会去检测是否有没有el这个配置，如果没有，则会等待vm.$mounted(el)的调用。接着检测是否有没有template这个配置。如果有，这将这个传入render函数进行编译，如果没有，则将el元素内部的dom作为template参数传入render。对于这个周期如果不涉及到事件绑定方面的事件可以在这个周期进行操作 mounted周期这个周期是完成将构建的虚拟dom渲染到页面上的操作，这个时候可以对整个页面进行渲染完成后的各种动态操作 beforeDestroy周期和destroyed周期beforeDestroy周期和destroyed周期主要涉及到组件的!销毁,目前尚未涉及，等涉及了再补上]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event loop学习回顾]]></title>
    <url>%2F2017%2F10%2F27%2Fevent-loop%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[以前事件队列在我的认知范围内是只有两种：同步事件队列与异步事件队列。在处理事件队列过程中，浏览器会定期检测同步队列并从同步事件队列获取事件，并将之执行，在这过程中，异步队列触发回调事件时，会将其从异步队列中出队，加入到同步事件队列中，一直重复上述过程。 但在这里有个疑问，当多个异步事件队列同时到同步队列过程中是以什么标准去实现的？ 这个疑问直到前段时间看Vue有关的博客中无意间看到Chunk liu的Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心才了解到microTask的概念，才知道task的区分不是我原先理解的那么一回事。后面又读了Jake Archibald 写的Tasks， microtasks， queues and schedules才知道event loop到底是个怎么回事。 先说下task跟microTask的概念 tasktask 又称 macrotask。HTML 规范中 task 的有关章节是这么说的： 一个 eventloop 有一或多个 task 队列。每个 task 由一个确定的 task 源提供。从不同 task 源而来的 task 可能会放到不同的 task 队列中。例如，浏览器可能单独为鼠标键盘事件维护一个 task 队列，所有其他 task 都放到另一个 task 队列。通过区分 task 队列的优先级，使高优先级的 task 优先执行，保证更好的交互体验。 task源包括： DOM 操作任务源：如元素以非阻塞方式插入文档 用户交互任务源：如鼠标键盘事件。用户输入事件（如 click） 必须使用 task 队列 网络任务源：如 XHR 回调 history 回溯任务源：使用 history.back() 或者类似 API此外 setTimeout、setInterval、IndexDB 数据库操作等也是任务源。 microTaskmicroTask：规范上是这么说的：每个event loop都有一个microTask， microTask存在于microTask队列中。microTask主要分以下几种： Promise.then MutationObserver Object.observe其中Promise.then由于不同浏览器的实现有所不同，有些运行触发的是microTask，有些触发的触发的是task，不过标准上是触发microTask的 event loop的循环过程在说了task跟microTask的概念后再说下event loop的循环过程。先贴一下规范的说法(有点凑字数的嫌疑。。。)： An event loop must continually run through the following steps for as long as it exists: Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below. Set the event loop’s currently running task to the task selected in the previous step. Run: Run the selected task. Set the event loop’s currently running task back to null. Remove the task that was run in the run step above from its task queue. Microtasks: Perform a microtask checkpoint. //这里会执行所有的microtask Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.7.1 Let now be the value that would be returned by the Performance object’s now() method.7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:7.3 If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context’s top-level browsing context is in B.7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]7.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.7.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]7.12 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.Return to the first step of the event loop. 复述一下上面说的 在前5的步骤是找出存在task队列中时间最长的task，出队并将之执行。在第六步的时候将microTask队列中的microTask全部执行第七步，更新渲染：7.2到7.4，当前轮次的event loop中关联到的document对象会保持某些特定顺序，这些document对象都会执行需要执行UI render的，但是并不是所有关联到的document都需要更新UI(换个说法就是只有从UI Render收益的documnet才需要更新)，浏览器会判断这个document是否会从UI Render中获益，因为浏览器只需要保持60Hz的刷新率即可，而每轮event loop都是非常快的，所以没必要每个document都Render UI。7.5和7.6 run the resize steps/run the scroll steps不是说去执行resize和scroll。每次我们scoll的时候视口或者dom就已经立即scroll了，并把document或者dom加入到 pending scroll event targets中，而run the scroll steps具体做的则是遍历这些target，在target上触发scroll事件。run the resize steps也是相似的，这个步骤是触发resize事件。7.8和7.9 后续的media query, run CSS animations and send events等等也是相似的，都是触发事件，第10步和第11步则是执行我们熟悉的requestAnimationFrame回调和IntersectionObserver回调（第十步还是挺关键的,raf就是在这执行的！）。7.12 渲染UI，关键就在这了。第九步 继续执行event loop，又去执行task，microtasks和UI render。 个人理解是在event loop过程中，会循环检测各个task队列中的task，获取停留时间最久的task，出队并将之执行。在执行完后，会去检测microTask队列并执行在这个task过程中生成的microTask以及micorTask执行过程中生成microTask，在执行完成后进行页面的更新操作。这里举个🌰：1234567console.log('script start')setTimeout(() =&gt; console.log('setTimeout'), 0)Promise.resolve().then(() =&gt; console.log('Promise1')).then(() =&gt; console.log('Promise2'))console.log('script end') 执行结果如下12345script startscript endPromise1Promise2setTimeout 浏览器首先执行的是script解析的task，所以最先打印的是在这个task中执行的console.log，然后在这个过程中，Promise会生成了一个microTask并将其加入microTask队列中，setTimeout会生成一个task并将其加入task队列中。在执行完script解析这个task后，会去检测microTask队列，此时microtask队列中存在一个由Promise生成的microTask任务，将其执行后其返回结果又执行then，因此有生成一个microTask，将其加入到microTask队列中，执行完成后继续将microTask队列执行完成。在microTask队列执行完成后继续检测task队列，此时存在一个setTimeout生成的task，将其完成后最终结果就如上所示。 参考资料 Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！ Tasks, microtasks, queues and schedules 深入探究 eventloop 与浏览器渲染的时序问题 - 404Forest]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向数据绑定的实现]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[模仿vue的双向数据绑定 前段时间听了TGideas的一场交流会之后萌生了自己实现数据双向绑定的想法，于是在参考了DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm的逻辑后用TypeScript实现了一套简单的双向数据绑定的库项目地址在这学习vue的双向数据绑定 项目主要代码目录如下123456789101112src|--Yue|--|--util|--|--|--CompileUtil.ts|--|--|--Updater.ts|--|--Yue.ts|--|--Observer.ts|--|--Compile.ts|--|--Observer.ts|--|--Dep.ts|--|--Watcher.ts|--index.ts 整个项目通过src目录下的index.ts对外暴露引用，主体类是Yue目录下的Yue.ts。同时Yue类下面还有Observer.ts以及Compile.ts两个主要类。Observer类是用来建立Yue实例化后对象下的data数据的监测，Compile类是负责将自定义的一套html语法糖编译成浏览器所能理解的dom树util目录下存放着CompileUtil以及Updater两个工具类，CompileUtil类是编译工具类，Updater是数据更新工具类 双向数据绑定的实现逻辑 具体逻辑可以参考DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm这篇所讲的，我只是大概讲一下关于自己的理解。 建立对数据的监测。在Observer这个类中使用Object.defineProperty方法重新定义data上的数据，实现对data的数据劫持。在这个过程中为每个属性节点建立一个发布者，这个发布者是针对对应的属性节点以及其后代属性的。 模版的转换。 模版的获取。通过document.createDocumentFragment方法创建一个文档碎片，并通过appendChild方法将编译范围内的dom&gt;从文档树中移除并加入到文档碎片中。 模版的编译。通过node.childNodes递归遍历每个dom节点，使用正则匹配判断每个节点是否存在需要编译的文本，若存在，则将其跟data上的数据进行匹配，并创建一个订阅者将其加入到相应的发布者中。 通过在数据监测以及dom数据绑定的过程构建发布-订阅的设计模式，实现了双向数据绑定 存在的问题 在编译模版中多次引用同个data上的数据会导致重复的Watcher创建。 上述问题以后会继续研究，待续…]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
