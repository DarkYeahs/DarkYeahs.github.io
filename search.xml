<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于一道js题目的猜想]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%85%B3%E4%BA%8E%E4%B8%80%E9%81%93js%E9%A2%98%E7%9B%AE%E7%9A%84%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[昨天在GitHub上无意逛到了creeperyang的博客,在他博客的JavaScript问题集锦，看到了这道题：问题： 尝试解释下连等赋值的过程。下面的代码为什么是这样的输出？12345var a = &#123;n: 1&#125;; var b = a;a.x = a = &#123;n: 2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 博主是这样解释的： 按照es5规范，题中连等赋值等价于a.x = (a = {n: 2});，按优先获取左引用（lref），然后获取右引用（rref）的顺序，a.x和a中的a都指向了{n: 1}。至此，至关重要或者说最迷惑的一步明确。(a = {n: 2})执行完成后，变量a指向{n: 2}，并返回{n: 2};接着执行a.x = {n: 2}，这里的a就是b（指向{n: 1}），所以b.x就指向了{n: 2}。 后面自己想了下有点解释不通，因为当a的指向更改的时候，a.x中的a指向也应该同时更改，那么x属性也应该是在新的对象上添加，为什么会说这里的a仍然就是b即指向的是{n: 1},所以对原代码进行了改造：12345678var a = &#123;n: 1&#125;; var b = a;function test () &#123; return a = &#123;n: 2&#125;;&#125;a.x = test();console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 运行结果与原结果相同。在使用chrome的debugger查看代码运行的时候，发现chrome在运行过程中，运行到a.x = test()这行代码的时候会停留在a.x再运行test(),联系到关于属性在原型链上的搜索，作出以下的解释：a.x = a = {n: 2}在运行过程中浏览器会首先尝试读取属性x的值，即在{n: 1}上搜索x属性，在搜索不到的前提下又由于赋值的操作，会在{n: 1}上创建x属性并且x属性指向{n: 2},由于a的指向发生变更,所以a.x为undefined,b.x为{n: 2}]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.x周期简述]]></title>
    <url>%2F2017%2F10%2F28%2FVue2-x%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[首先贴一张大图，跟vue1.x相比。vue2.0渲染周期发生了较大的变化。Vue的生命周期变为beforeCreate（Vue1.x为created），created（vue1.x为beforeCompile），beforeMount（vue1.x为compile），mounted（vue1.x为ready）以及beforeDestroy，destroyed. beforeCreate周期在beforeCreate周期前是获取不到任何数据的，这个周期只是进行事件的初始化以及生命周期的初始化，在完成事件的初始化以及生命周期的初始化后会触发beforeCreate的钩子函数，对于无关数据与渲染后的dom操作的可以在这个周期开始执行 created周期在created周期前，对数据通过vue本身改造Object.prototype.setter 和Object.prototype.getter两个函数对传入的数据进行监听，在这个周期可以对无关dom的操作进行处理，比如根据传入的数据获取后台数据等操作可以在这个周期进行 beforeMount周期在这个周期主要完成虚拟dom操作，Vue会去检测是否有没有el这个配置，如果没有，则会等待vm.$mounted(el)的调用。接着检测是否有没有template这个配置。如果有，这将这个传入render函数进行编译，如果没有，则将el元素内部的dom作为template参数传入render。对于这个周期如果不涉及到事件绑定方面的事件可以在这个周期进行操作 mounted周期这个周期是完成将构建的虚拟dom渲染到页面上的操作，这个时候可以对整个页面进行渲染完成后的各种动态操作 beforeDestroy周期和destroyed周期beforeDestroy周期和destroyed周期主要涉及到组件的!销毁,目前尚未涉及，等涉及了再补上]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event loop学习回顾]]></title>
    <url>%2F2017%2F10%2F27%2Fevent-loop%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[以前事件队列在我的认知范围内是只有两种：同步事件队列与异步事件队列。在处理事件队列过程中，浏览器会定期检测同步队列并从同步事件队列获取事件，并将之执行，在这过程中，异步队列触发回调事件时，会将其从异步队列中出队，加入到同步事件队列中，一直重复上述过程。 但在这里有个疑问，当多个异步事件队列同时到同步队列过程中是以什么标准去实现的？ 这个疑问直到前段时间看Vue有关的博客中无意间看到Chunk liu的Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心才了解到microTask的概念，才知道task的区分不是我原先理解的那么一回事。后面又读了Jake Archibald 写的Tasks， microtasks， queues and schedules才知道event loop到底是个怎么回事。 先说下task跟microTask的概念 tasktask 又称 macrotask。HTML 规范中 task 的有关章节是这么说的： 一个 eventloop 有一或多个 task 队列。每个 task 由一个确定的 task 源提供。从不同 task 源而来的 task 可能会放到不同的 task 队列中。例如，浏览器可能单独为鼠标键盘事件维护一个 task 队列，所有其他 task 都放到另一个 task 队列。通过区分 task 队列的优先级，使高优先级的 task 优先执行，保证更好的交互体验。 task源包括： DOM 操作任务源：如元素以非阻塞方式插入文档 用户交互任务源：如鼠标键盘事件。用户输入事件（如 click） 必须使用 task 队列 网络任务源：如 XHR 回调 history 回溯任务源：使用 history.back() 或者类似 API此外 setTimeout、setInterval、IndexDB 数据库操作等也是任务源。 microTaskmicroTask：规范上是这么说的：每个event loop都有一个microTask， microTask存在于microTask队列中。microTask主要分以下几种： Promise.then MutationObserver Object.observe其中Promise.then由于不同浏览器的实现有所不同，有些运行触发的是microTask，有些触发的触发的是task，不过标准上是触发microTask的 event loop的循环过程在说了task跟microTask的概念后再说下event loop的循环过程。先贴一下规范的说法(有点凑字数的嫌疑。。。)： An event loop must continually run through the following steps for as long as it exists: Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below. Set the event loop’s currently running task to the task selected in the previous step. Run: Run the selected task. Set the event loop’s currently running task back to null. Remove the task that was run in the run step above from its task queue. Microtasks: Perform a microtask checkpoint. //这里会执行所有的microtask Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.7.1 Let now be the value that would be returned by the Performance object’s now() method.7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:7.3 If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context’s top-level browsing context is in B.7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]7.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.7.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]7.12 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.Return to the first step of the event loop. 复述一下上面说的 在前5的步骤是找出存在task队列中时间最长的task，出队并将之执行。在第六步的时候将microTask队列中的microTask全部执行第七步，更新渲染：7.2到7.4，当前轮次的event loop中关联到的document对象会保持某些特定顺序，这些document对象都会执行需要执行UI render的，但是并不是所有关联到的document都需要更新UI(换个说法就是只有从UI Render收益的documnet才需要更新)，浏览器会判断这个document是否会从UI Render中获益，因为浏览器只需要保持60Hz的刷新率即可，而每轮event loop都是非常快的，所以没必要每个document都Render UI。7.5和7.6 run the resize steps/run the scroll steps不是说去执行resize和scroll。每次我们scoll的时候视口或者dom就已经立即scroll了，并把document或者dom加入到 pending scroll event targets中，而run the scroll steps具体做的则是遍历这些target，在target上触发scroll事件。run the resize steps也是相似的，这个步骤是触发resize事件。7.8和7.9 后续的media query, run CSS animations and send events等等也是相似的，都是触发事件，第10步和第11步则是执行我们熟悉的requestAnimationFrame回调和IntersectionObserver回调（第十步还是挺关键的,raf就是在这执行的！）。7.12 渲染UI，关键就在这了。第九步 继续执行event loop，又去执行task，microtasks和UI render。 个人理解是在event loop过程中，会循环检测各个task队列中的task，获取停留时间最久的task，出队并将之执行。在执行完后，会去检测microTask队列并执行在这个task过程中生成的microTask以及micorTask执行过程中生成microTask，在执行完成后进行页面的更新操作。这里举个🌰：1234567console.log(&apos;script start&apos;)setTimeout(() =&gt; console.log(&apos;setTimeout&apos;), 0)Promise.resolve().then(() =&gt; console.log(&apos;Promise1&apos;)).then(() =&gt; console.log(&apos;Promise2&apos;))console.log(&apos;script end&apos;) 执行结果如下12345script startscript endPromise1Promise2setTimeout 浏览器首先执行的是script解析的task，所以最先打印的是在这个task中执行的console.log，然后在这个过程中，Promise会生成了一个microTask并将其加入microTask队列中，setTimeout会生成一个task并将其加入task队列中。在执行完script解析这个task后，会去检测microTask队列，此时microtask队列中存在一个由Promise生成的microTask任务，将其执行后其返回结果又执行then，因此有生成一个microTask，将其加入到microTask队列中，执行完成后继续将microTask队列执行完成。在microTask队列执行完成后继续检测task队列，此时存在一个setTimeout生成的task，将其完成后最终结果就如上所示。 参考资料 Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！ Tasks, microtasks, queues and schedules 深入探究 eventloop 与浏览器渲染的时序问题 - 404Forest]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向数据绑定的实现]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[模仿vue的双向数据绑定 前段时间听了TGideas的一场交流会之后萌生了自己实现数据双向绑定的想法，于是在参考了DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm的逻辑后用TypeScript实现了一套简单的双向数据绑定的库项目地址在这学习vue的双向数据绑定 项目主要代码目录如下123456789101112src|--Yue|--|--util|--|--|--CompileUtil.ts|--|--|--Updater.ts|--|--Yue.ts|--|--Observer.ts|--|--Compile.ts|--|--Observer.ts|--|--Dep.ts|--|--Watcher.ts|--index.ts 整个项目通过src目录下的index.ts对外暴露引用，主体类是Yue目录下的Yue.ts。同时Yue类下面还有Observer.ts以及Compile.ts两个主要类。Observer类是用来建立Yue实例化后对象下的data数据的监测，Compile类是负责将自定义的一套html语法糖编译成浏览器所能理解的dom树util目录下存放着CompileUtil以及Updater两个工具类，CompileUtil类是编译工具类，Updater是数据更新工具类 双向数据绑定的实现逻辑 具体逻辑可以参考DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm这篇所讲的，我只是大概讲一下关于自己的理解。 建立对数据的监测。在Observer这个类中使用Object.defineProperty方法重新定义data上的数据，实现对data的数据劫持。在这个过程中为每个属性节点建立一个发布者，这个发布者是针对对应的属性节点以及其后代属性的。 模版的转换。 模版的获取。通过document.createDocumentFragment方法创建一个文档碎片，并通过appendChild方法将编译范围内的dom&gt;从文档树中移除并加入到文档碎片中。 模版的编译。通过node.childNodes递归遍历每个dom节点，使用正则匹配判断每个节点是否存在需要编译的文本，若存在，则将其跟data上的数据进行匹配，并创建一个订阅者将其加入到相应的发布者中。 通过在数据监测以及dom数据绑定的过程构建发布-订阅的设计模式，实现了双向数据绑定 存在的问题 在编译模版中多次引用同个data上的数据会导致重复的Watcher创建。 上述问题以后会继续研究，待续…]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
