<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[缓存整理]]></title>
    <url>%2F2019%2F04%2F25%2F%E7%BC%93%E5%AD%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理下关于浏览器请求缓存浏览器请求缓存分为强缓存与协商缓存 强缓存浏览器访问资源前会先检查本地是否请求过该资源，如果请求过该资源，会先判断该资源上一次请求的expires字段以及cache-control字段。如果存在expires字段以及cache-control字段，会判断当前是否过期，如果过期，则会向服务器发起请求，如果未过期，则不会向服务器发起请求，直接使用本地缓存。 强缓存还分from dist cache以及from memory cache，from dist cache字面上指的是从硬盘里读取缓存，from memory cache指的是从缓存中读取，如果浏览器关闭，from memory cache会直接进行清除。 强缓存的状态码是200 协商缓存在当前强缓存过期的情况下，会向服务器发起请求，在发起的请求头上会带上ETag字段或者last modify字段，服务器会优先校验请求头的ETag字段与服务器上文件的字段是否一致，一致则返回304响应码并在返回的请求头上带上If-not-match字段，告诉浏览器使用本地缓存。如果没有ETag字段，则会校验请求头中的Last-Modify字段，与服务器文件上最后一次修改时间进行比较，如果一致则返回304并在返回的请求头上带上If-modify-match，浏览器使用本地缓存。如果两者校验都不通过，则返回200状态码，浏览器从服务器加载资源。 协商缓存校验过程中，ETag/If-not-match以及last-modify/if-modify-since是配套校验的，并且ETag/If-not-match的优先级比last-modify/if-modify-since优先级高，因为服务器校验的时间精度可能不准确以及文件内容未修改但文件修改时间未发生变化等。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[近期问题汇总]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%BF%91%E6%9C%9F%E5%85%BC%E5%AE%B9%E8%A1%8C%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[整理下近期工作中遇到的问题 安卓rem兼容问题 在部分安卓机型里存在1rem不等于根元素上字体大小的问题。理论上如果设定根元素大小为16px，那么1rem应该就等于16px，但是在部分安卓机型（常见vivo，oppo机型）中会出现1rem不等于16px的现象。此时可以根据根元素的字体大小设定一个dom元素插入文档，通过调用dom元素上的getBoundingClientRect获取元素在dom文档中实际的大小，通过理论的数值与真实的数值进行判断。如果两个数值不等，则将根元素上的字体大小按照理论数值与真实数值的比例放大或者缩小。 如果使用rem进行布局，那么会经常出现计算出来的元素大小像素存在小数点，而浏览器渲染页面是按照屏幕的渲染单位进行渲染的，这种情况下无法避免，只能在布局中进行留意。 placeholder字体发生变化会导致placeholder字体发生位移通过设定::-webkit-input-placeholder对input下的placeholder属性设定的预留字体进行加粗变化字体类型会导致placeholder设定的字体在小米手机上发生位移 华为 华为不支持多行flex布局。华为机型不支持多行flex布局，因为大多数华为机型只支持古老的flex-box布局，flex-box不支持多行布局，只支持单行的flex布局。所以在选定多行布局的时候，对flex的使用要多加谨慎，且对flex的预编译要选定兼容到最老的那一个选项。 虽然在移动端使用transform以及设定translate3D可以开启硬件加速，但是要考虑在部分机型使用后页面滑动元素滚动怪异的问题，常见于页面发生滑动，使用了transform属性的元素会滞后滑动（不同步滑动）多数安卓浏览器播放视频会使用自身的浏览器，且浏览器无法被遮盖 ios vue以及react后退会导致页面空白 ios下元素需要使用onstarttouch属性才能激活元素的active渲染 iphoneX在safari浏览器横屏下两边会自动留白工具 使用webpack打包时如果webpack的配置中output.jsonpfunction配置重复会导致打包资源发生冲突 offline-plugin 离线资源加载优化，二次加载的时间可以优化到只需要原先加载时间的1/3，但使用会导致qq分享失败，影响到qq的分享接口的api报错（问题暂时未知）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行上下文知识整理]]></title>
    <url>%2F2017%2F11%2F02%2FJavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前几天在GitHub上看到了mqyqingfeng的博客，在上面看了他的JavaScript深入系列中关于执行上下文部分的讲述，对于JavaScript的执行上下文有了进一步的了解,在这里总结下我新的认识。 执行上下文首先说下什么是执行上下文，HTML规范上是这么说的 When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context. 简单的来说就是当可执行代码被执行的时候，会创建一个执行上下文，这个上下文就是当前可执行代码的执行环境。并且多个执行上下文会构成一个执行上下文栈，栈底部始终存在着一个GlobalContext。其中可执行代码分为1. 全局代码;2. 函数代码;3. eval代码。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 变量对象变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。其中，在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行上下文的代码会分成两个阶段进行处理：分析和执行。 分析当进入执行上下文时，这时候只是进行代码的解析(变量命名的提升就在这一阶段)，变量对象会包括：a) 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined b) 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 c) 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 执行在执行阶段，浏览器会顺序执行代码，根据代码，修改变量对象的值 举个🌰：12345678function foo (a) &#123; var b = 1 function bar () &#123; &#125; var d = function () &#123;&#125; b = 2&#125;foo(1) 在分析阶段，这个时候的AO是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, bar: reference to function c()&#123;&#125;, d: undefined&#125; 在执行阶段，这个时候的AO是：12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 2, bar: reference to function c()&#123;&#125;, d: reference to FunctionExpression "d"&#125; 作用域链在上面说到每个上下文都有一个变量对象，而由多个上下文的变量对象构成的链表就叫做作用域链。其中，函数的作用域链在函数定义的时候就决定了。在函数创建的时候，会把所有的父变量对象保存到函数的一个内部属性中。举个🌰：12345function foo() &#123; function bar() &#123; ... &#125;&#125; 函数创建时，各自的[[scope]]为：12345678foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO, globalContext.VO]; 当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 this再这里就先不展开了，单纯从ECMAScript的角度讲有点绕，也有点多。。。懒病又犯了。。。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于一道js题目的猜想]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%85%B3%E4%BA%8E%E4%B8%80%E9%81%93js%E9%A2%98%E7%9B%AE%E7%9A%84%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[昨天在GitHub上无意逛到了creeperyang的博客,在他博客的JavaScript问题集锦，看到了这道题：问题： 尝试解释下连等赋值的过程。下面的代码为什么是这样的输出？12345var a = &#123;n: 1&#125;; var b = a;a.x = a = &#123;n: 2&#125;; console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 博主是这样解释的： 按照es5规范，题中连等赋值等价于a.x = (a = {n: 2});，按优先获取左引用（lref），然后获取右引用（rref）的顺序，a.x和a中的a都指向了{n: 1}。至此，至关重要或者说最迷惑的一步明确。(a = {n: 2})执行完成后，变量a指向{n: 2}，并返回{n: 2};接着执行a.x = {n: 2}，这里的a就是b（指向{n: 1}），所以b.x就指向了{n: 2}。 后面自己想了下有点解释不通，因为当a的指向更改的时候，a.x中的a指向也应该同时更改，那么x属性也应该是在新的对象上添加，为什么会说这里的a仍然就是b即指向的是{n: 1},所以对原代码进行了改造：12345678var a = &#123;n: 1&#125;; var b = a;function test () &#123; return a = &#123;n: 2&#125;;&#125;a.x = test();console.log(a.x);// --&gt; undefined console.log(b.x);// --&gt; &#123;n:2&#125; 运行结果与原结果相同。在使用chrome的debugger查看代码运行的时候，发现chrome在运行过程中，运行到a.x = test()这行代码的时候会停留在a.x再运行test(),联系到关于属性在原型链上的搜索，作出以下的解释：a.x = a = {n: 2}在运行过程中浏览器会首先尝试读取属性x的值，即在{n: 1}上搜索x属性，在搜索不到的前提下又由于赋值的操作，会在{n: 1}上创建x属性并且x属性指向{n: 2},由于a的指向发生变更,所以a.x为undefined,b.x为{n: 2}js执行连等赋值语句之前，会取出变量的引用。a.x = a = {n: 2}在运行过程中，由于.运算符的优先级比=运算符优先级高，所以浏览器会先执行a.x的操作，也就是读取a的操作，此时a仍指向{n: 1}，执行结果为undefined，但是由于赋值操作，此时会给{n: 1}增加x属性这个值，所以a.x中的a仍然指向{n: 1}，且属性x的值为a = {n: 2}的执行结果。因为在执行a = {n: 2}的过程中改变了a的指向，所以console.log(a.x)其结果为undefined，b.x结果为{n: 1}。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2.x周期简述]]></title>
    <url>%2F2017%2F10%2F28%2FVue2-x%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[首先贴一张大图，跟vue1.x相比。vue2.0渲染周期发生了较大的变化。Vue的生命周期变为beforeCreate（Vue1.x为created），created（vue1.x为beforeCompile），beforeMount（vue1.x为compile），mounted（vue1.x为ready）以及beforeDestroy，destroyed. beforeCreate周期在beforeCreate周期前是获取不到任何数据的，这个周期只是进行事件的初始化以及生命周期的初始化，在完成事件的初始化以及生命周期的初始化后会触发beforeCreate的钩子函数，对于无关数据与渲染后的dom操作的可以在这个周期开始执行 created周期在created周期前，对数据通过vue本身改造Object.prototype.setter 和Object.prototype.getter两个函数对传入的数据进行监听，在这个周期可以对无关dom的操作进行处理，比如根据传入的数据获取后台数据等操作可以在这个周期进行 beforeMount周期在这个周期主要完成虚拟dom操作，Vue会去检测是否有没有el这个配置，如果没有，则会等待vm.$mounted(el)的调用。接着检测是否有没有template这个配置。如果有，这将这个传入render函数进行编译，如果没有，则将el元素内部的dom作为template参数传入render。对于这个周期如果不涉及到事件绑定方面的事件可以在这个周期进行操作 mounted周期这个周期是完成将构建的虚拟dom渲染到页面上的操作，这个时候可以对整个页面进行渲染完成后的各种动态操作 beforeDestroy周期和destroyed周期beforeDestroy周期和destroyed周期主要涉及到组件的!销毁,目前尚未涉及，等涉及了再补上]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event loop学习回顾]]></title>
    <url>%2F2017%2F10%2F27%2Fevent-loop%E5%AD%A6%E4%B9%A0%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[以前事件队列在我的认知范围内是只有两种：同步事件队列与异步事件队列。在处理事件队列过程中，浏览器会定期检测同步队列并从同步事件队列获取事件，并将之执行，在这过程中，异步队列触发回调事件时，会将其从异步队列中出队，加入到同步事件队列中，一直重复上述过程。 但在这里有个疑问，当多个异步事件队列同时到同步队列过程中是以什么标准去实现的？ 这个疑问直到前段时间看Vue有关的博客中无意间看到Chunk liu的Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心才了解到microTask的概念，才知道task的区分不是我原先理解的那么一回事。后面又读了Jake Archibald 写的Tasks， microtasks， queues and schedules才知道event loop到底是个怎么回事。 先说下task跟microTask的概念 tasktask 又称 macrotask。HTML 规范中 task 的有关章节是这么说的： 一个 eventloop 有一或多个 task 队列。每个 task 由一个确定的 task 源提供。从不同 task 源而来的 task 可能会放到不同的 task 队列中。例如，浏览器可能单独为鼠标键盘事件维护一个 task 队列，所有其他 task 都放到另一个 task 队列。通过区分 task 队列的优先级，使高优先级的 task 优先执行，保证更好的交互体验。 task源包括： DOM 操作任务源：如元素以非阻塞方式插入文档 用户交互任务源：如鼠标键盘事件。用户输入事件（如 click） 必须使用 task 队列 网络任务源：如 XHR 回调 history 回溯任务源：使用 history.back() 或者类似 API此外 setTimeout、setInterval、IndexDB 数据库操作等也是任务源。 microTaskmicroTask：规范上是这么说的：每个event loop都有一个microTask， microTask存在于microTask队列中。microTask主要分以下几种： Promise.then MutationObserver Object.observe其中Promise.then由于不同浏览器的实现有所不同，有些运行触发的是microTask，有些触发的触发的是task，不过标准上是触发microTask的 event loop的循环过程在说了task跟microTask的概念后再说下event loop的循环过程。先贴一下规范的说法(有点凑字数的嫌疑。。。)： An event loop must continually run through the following steps for as long as it exists: Select the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below. Set the event loop’s currently running task to the task selected in the previous step. Run: Run the selected task. Set the event loop’s currently running task back to null. Remove the task that was run in the run step above from its task queue. Microtasks: Perform a microtask checkpoint. //这里会执行所有的microtask Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.7.1 Let now be the value that would be returned by the Performance object’s now() method.7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:7.3 If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context’s top-level browsing context is in B.7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]7.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.7.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]7.12 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.Return to the first step of the event loop. 复述一下上面说的 在前5的步骤是找出存在task队列中时间最长的task，出队并将之执行。在第六步的时候将microTask队列中的microTask全部执行第七步，更新渲染：7.2到7.4，当前轮次的event loop中关联到的document对象会保持某些特定顺序，这些document对象都会执行需要执行UI render的，但是并不是所有关联到的document都需要更新UI(换个说法就是只有从UI Render收益的documnet才需要更新)，浏览器会判断这个document是否会从UI Render中获益，因为浏览器只需要保持60Hz的刷新率即可，而每轮event loop都是非常快的，所以没必要每个document都Render UI。7.5和7.6 run the resize steps/run the scroll steps不是说去执行resize和scroll。每次我们scoll的时候视口或者dom就已经立即scroll了，并把document或者dom加入到 pending scroll event targets中，而run the scroll steps具体做的则是遍历这些target，在target上触发scroll事件。run the resize steps也是相似的，这个步骤是触发resize事件。7.8和7.9 后续的media query, run CSS animations and send events等等也是相似的，都是触发事件，第10步和第11步则是执行我们熟悉的requestAnimationFrame回调和IntersectionObserver回调（第十步还是挺关键的,raf就是在这执行的！）。7.12 渲染UI，关键就在这了。第九步 继续执行event loop，又去执行task，microtasks和UI render。 个人理解是在event loop过程中，会循环检测各个task队列中的task，获取停留时间最久的task，出队并将之执行。在执行完后，会去检测microTask队列并执行在这个task过程中生成的microTask以及micorTask执行过程中生成microTask，在执行完成后进行页面的更新操作。这里举个🌰：1234567console.log('script start')setTimeout(() =&gt; console.log('setTimeout'), 0)Promise.resolve().then(() =&gt; console.log('Promise1')).then(() =&gt; console.log('Promise2'))console.log('script end') 执行结果如下12345script startscript endPromise1Promise2setTimeout 浏览器首先执行的是script解析的task，所以最先打印的是在这个task中执行的console.log，然后在这个过程中，Promise会生成了一个microTask并将其加入microTask队列中，setTimeout会生成一个task并将其加入task队列中。在执行完script解析这个task后，会去检测microTask队列，此时microtask队列中存在一个由Promise生成的microTask任务，将其执行后其返回结果又执行then，因此有生成一个microTask，将其加入到microTask队列中，执行完成后继续将microTask队列执行完成。在microTask队列执行完成后继续检测task队列，此时存在一个setTimeout生成的task，将其完成后最终结果就如上所示。 参考资料 Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！ Tasks, microtasks, queues and schedules 深入探究 eventloop 与浏览器渲染的时序问题 - 404Forest]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双向数据绑定的实现]]></title>
    <url>%2F2017%2F10%2F26%2F%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[模仿vue的双向数据绑定 前段时间听了TGideas的一场交流会之后萌生了自己实现数据双向绑定的想法，于是在参考了DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm的逻辑后用TypeScript实现了一套简单的双向数据绑定的库项目地址在这学习vue的双向数据绑定 项目主要代码目录如下123456789101112src|--Yue|--|--util|--|--|--CompileUtil.ts|--|--|--Updater.ts|--|--Yue.ts|--|--Observer.ts|--|--Compile.ts|--|--Observer.ts|--|--Dep.ts|--|--Watcher.ts|--index.ts 整个项目通过src目录下的index.ts对外暴露引用，主体类是Yue目录下的Yue.ts。同时Yue类下面还有Observer.ts以及Compile.ts两个主要类。Observer类是用来建立Yue实例化后对象下的data数据的监测，Compile类是负责将自定义的一套html语法糖编译成浏览器所能理解的dom树util目录下存放着CompileUtil以及Updater两个工具类，CompileUtil类是编译工具类，Updater是数据更新工具类 双向数据绑定的实现逻辑 具体逻辑可以参考DMQ/mvvm: 剖析vue实现原理，自己动手实现mvvm这篇所讲的，我只是大概讲一下关于自己的理解。 建立对数据的监测。在Observer这个类中使用Object.defineProperty方法重新定义data上的数据，实现对data的数据劫持。在这个过程中为每个属性节点建立一个发布者，这个发布者是针对对应的属性节点以及其后代属性的。 模版的转换。 模版的获取。通过document.createDocumentFragment方法创建一个文档碎片，并通过appendChild方法将编译范围内的dom&gt;从文档树中移除并加入到文档碎片中。 模版的编译。通过node.childNodes递归遍历每个dom节点，使用正则匹配判断每个节点是否存在需要编译的文本，若存在，则将其跟data上的数据进行匹配，并创建一个订阅者将其加入到相应的发布者中。 通过在数据监测以及dom数据绑定的过程构建发布-订阅的设计模式，实现了双向数据绑定 存在的问题 在编译模版中多次引用同个data上的数据会导致重复的Watcher创建。 上述问题以后会继续研究，待续…]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
